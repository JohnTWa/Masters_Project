from _SETUP_ import set_directory
set_directory()

from common.reset import reset
from m3_message_receiving.edge_detection import detect_edges_with_orig_index
from common.hamming_code import hamming_decode
from m3_message_receiving.ASK_synchronous.determine_states import determine_states
import common.binary_image as bin_img
import common.image_displaying as img_disp
from m3_message_receiving.ASK_asynchronous.pause_location import determine_pause_bounds  # make sure this is available

# Packages
import logging
import os
import time

## Boolean flag: Choose whether to use Hamming decoding
HAMMING_DECODE = False

## Expected Image Dimensions and Chunk Parameters ##
EXPECTED_WIDTH = 128   # in pixels
EXPECTED_HEIGHT = 128  # in pixels
CHUNK_SIZE = 8         # each chunk is 8 bits (representing 8 pixels)
SIGNALS_PER_ROW = EXPECTED_WIDTH // CHUNK_SIZE  # e.g., 128/8 = 16 signals per row
expected_total_signals = EXPECTED_HEIGHT * SIGNALS_PER_ROW  # e.g., 128 * 16 = 2048

## Transmission Key Settings ##
FIRST_KEY = 3
LAST_KEY = 110  # Adjust so that TOTAL_KEYS equals the number of transmitting keys; e.g., keys 3 to 110 yields 108 keys.
TOTAL_KEYS = LAST_KEY - FIRST_KEY + 1  # should be 108

## Determine frame structure ##
# The transmitter sends signals round-robin over all keys.
full_frames = expected_total_signals // TOTAL_KEYS      # number of full frames
partial_frame_signals = expected_total_signals % TOTAL_KEYS # signals in the final partial frame
logging.info(f"Expected total signals: {expected_total_signals}")
logging.info(f"Full frames: {full_frames}, Partial frame signals: {partial_frame_signals}")

## Define file paths ##
log_file_path = 'files/logs/ASK_image_demodulation.log'
key_levels_and_events_folder = 'files/key_light_levels'
rgb_csv_path = 'files/spreadsheets/s5_rgb_normalised.csv'
CLK_csv_path = os.path.join(key_levels_and_events_folder, 'light_levels_CLK.csv')
SGL_csv_path = os.path.join(key_levels_and_events_folder, 'light_levels_SGL.csv')
binary_csv_path = 'files/spreadsheets/s8_binary.csv'
output_image_base = 'files/images/received_image_block_'  # output images will be named with block index and .pbm

# Configure the logger
logging.basicConfig(
    filename=log_file_path,
    filemode='w',
    format='%(asctime)s \t %(levelname)s \t %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

## Signal parameters ##
codeword_bits = 11  # for Hamming; adjust if needed
frequency = 10      # nominal transmission frequency in Hz (used only for logging here)
camera_sample_rate = 60  # camera framerate in fps
frame_bits = codeword_bits  # for logging purposes

## Reset Files ##
reset(binary_csv_path, output_image_base + "dummy.pbm", key_levels_and_events_folder)

## Generate CLK and SGL CSVs from the RGB CSV ##
# This call creates (or updates) the CLK and SGL CSV files.
CLK = detect_edges_with_orig_index(rgb_csv_path, 0, CLK_csv_path, threshold_fraction=0.2)
SGL = detect_edges_with_orig_index(rgb_csv_path, 3, SGL_csv_path, threshold_fraction=0.2)
frame_bounds = list(zip(SGL[::2], SGL[1::2]))  # each frame is between consecutive SGL edges
logger.info(f"Clock Flips: {len(CLK)}, Signal Flips: {len(SGL)}, Frames (per key): {len(frame_bounds)}")
logger.info(f"Bits per Frame: expected-{frame_bits}, detected-{len(CLK)/len(frame_bounds)}")

## Detect Pause Boundaries ##
# Assume a pause is at least 1 second long; use pause_rows = camera_sample_rate (e.g., 60).
pause_rows = 30
pause_bounds = determine_pause_bounds(CLK_csv_path, pause_rows, mark=False)
logger.info(f"Detected pause bounds: {pause_bounds}")

# Define block boundaries based on pause bounds.
# Here we assume that the first transmission block starts at the end of the first pause.
csv_start = 2  # data starts at row 2 after header
if pause_bounds:
    # First block: start at first pause end + 1, end at row before second pause begins (if exists)
    block_boundaries = []
    first_block_start = pause_bounds[0][1] + 1
    if len(pause_bounds) > 1:
        block_boundaries.append((first_block_start, pause_bounds[1][0] - 1))
    else:
        block_boundaries.append((first_block_start, None))
    # Subsequent blocks: every pair of pauses defines a block.
    for i in range(2, len(pause_bounds), 2):
        start_block = pause_bounds[i][1] + 1
        end_block = pause_bounds[i+1][0] - 1 if i+1 < len(pause_bounds) else None
        block_boundaries.append((start_block, end_block))
else:
    # No pauses detected: treat entire data as one block.
    block_boundaries = [(csv_start, None)]
logger.info(f"Derived transmission block boundaries (CSV row indices): {block_boundaries}")

## Receive Data Chunks, grouped by transmitting key ##
# We'll store signals in a dictionary:
# Key: transmitting key, Value: list of signals (in order)
received_signals_by_key = {}

for key in range(FIRST_KEY, LAST_KEY + 1):
    received_signals_by_key[key] = []
    colour_n = key % 3
    column = (key - 1) * 3 + colour_n
    colour_dictionary = {0: 'R', 1: 'G', 2: 'B'}
    colour = colour_dictionary[colour_n]
    logger.info(f"Processing Key {key}, Colour {colour}, Column {column}")

    levels_and_events_csv_path = os.path.join(key_levels_and_events_folder, f"light_levels_key_{key}.csv")
    _ = detect_edges_with_orig_index(rgb_csv_path, column, levels_and_events_csv_path, threshold_fraction=0.1)
    logger.info(f"|Reading key {key}, column {column}")

    # For each frame bound, receive one signal (chunk) from this key.
    for frame_bound in frame_bounds:
        logger.info(f"||Processing frame for key {key}, frame_bound {frame_bound}")
        codeword = determine_states(levels_and_events_csv_path, CLK, frame_bound)
        logger.info(f"||Received codeword: {codeword}")
        if HAMMING_DECODE:
            payload = hamming_decode(codeword)
            logger.info(f"||Decoded payload (binary chunk): {payload}")
        else:
            payload = codeword
            logger.info(f"||Using raw codeword as payload: {payload}")
        received_signals_by_key[key].append(payload)

    # Determine expected signals for this key:
    # Keys with (key - FIRST_KEY) < partial_frame_signals should have (full_frames + 1) signals;
    # others should have full_frames signals.
    expected_signals = full_frames + (1 if (key - FIRST_KEY) < partial_frame_signals else 0)
    while len(received_signals_by_key[key]) < expected_signals:
        logger.warning(f"Key {key} is missing a signal for a frame; padding with zeros.")
        received_signals_by_key[key].append("0" * CHUNK_SIZE)

## Reassemble Overall Signal Sequence ##
# First, reassemble the overall signal sequence (all frames) in round-robin order as in the original.
overall_signals_all = []
for frame_index in range(full_frames):
    for key in range(FIRST_KEY, LAST_KEY + 1):
        overall_signals_all.append(received_signals_by_key[key][frame_index])
for key in range(FIRST_KEY, FIRST_KEY + partial_frame_signals):
    overall_signals_all.append(received_signals_by_key[key][full_frames])
logger.info(f"Total signals reassembled (all frames): {len(overall_signals_all)}")
logger.info(f"Expected total signals: {expected_total_signals}")

## Now, Segment the Frames into Blocks Based on Pause Boundaries ##
# We assign frame indices to blocks based on the starting CSV row of each frame.
# Assume each frame_bound is a tuple (fstart, fend) representing CSV rows.
block_frame_indices = []  # list of lists; each inner list contains the frame indices belonging to that block.
for (block_start, block_end) in block_boundaries:
    indices = []
    for i, (fstart, _) in enumerate(frame_bounds):
        # If block_end is None, take frames with fstart >= block_start.
        if block_end is None:
            if fstart >= block_start:
                indices.append(i)
        else:
            if block_start <= fstart <= block_end:
                indices.append(i)
    block_frame_indices.append(indices)
logger.info(f"Frame indices per transmission block: {block_frame_indices}")

## For Each Block, Reassemble the Image ##
# (Assuming each block transmits a full image of EXPECTED_HEIGHT rows.)
block_number = 0
for indices in block_frame_indices:
    if not indices:
        logger.warning(f"No frames found for block {block_number}; skipping.")
        block_number += 1
        continue

    # For each key, extract the signals corresponding to these frame indices.
    block_signals_by_key = {}
    for key in range(FIRST_KEY, LAST_KEY + 1):
        sigs = received_signals_by_key[key]
        block_signals_by_key[key] = [sigs[i] for i in indices if i < len(sigs)]

    # Determine the number of frames available for this block (minimum across keys)
    block_frames = min(len(s) for s in block_signals_by_key.values())
    logger.info(f"Block {block_number}: Using {block_frames} frames for reassembly.")

    # Reassemble overall signals for this block in round-robin order.
    overall_signals = []
    for frame_index in range(block_frames):
        for key in range(FIRST_KEY, LAST_KEY + 1):
            overall_signals.append(block_signals_by_key[key][frame_index])
    total_signals = len(overall_signals)
    logger.info(f"Block {block_number}: Total signals reassembled: {total_signals}")

    # Check that we have at least the expected total signals.
    if total_signals < expected_total_signals:
        logger.error(f"Block {block_number}: Not enough signals received to reconstruct the full image!")
        block_number += 1
        continue
    overall_signals = overall_signals[:expected_total_signals]  # truncate extras if any

    # Reassemble image rows.
    rows = []
    for row_index in range(EXPECTED_HEIGHT):
        row_signals = overall_signals[row_index * SIGNALS_PER_ROW:(row_index + 1) * SIGNALS_PER_ROW]
        row_bin_str = "".join(row_signals)
        logger.info(f"Block {block_number} - Row {row_index+1}: {row_bin_str}")
        row = [int(bit) for bit in row_bin_str]
        rows.append(row)

    # Write and display the received image for this block.
    output_file = f"{output_image_base}{block_number}.pbm"
    bin_img.write_p1_from_rows(rows, output_file)
    logger.info(f"Block {block_number}: Received image saved to {output_file}")
    img_disp.display_image(output_file)
    # Optionally, compare with the original image:
    bin_img.compare_pbm_files('files/images/dog_P1.pbm', output_file, f'files/images/received_image_diff_block_{block_number}.png')
    block_number += 1